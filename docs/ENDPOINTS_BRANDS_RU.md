# BRANDS ROUTER — Функциональное описание эндпоинтов

Документ фиксирует поведение публичных и админских маршрутов брендов. Содержит: что делает эндпоинт, как реализован на уровне выборки/проверок, почему нужен с точки зрения бизнес-логики. Без оценок и советов.

## 1. Публичные эндпоинты (`/api/brands`)

### GET /api/brands/

Что: возвращает постраничный список брендов.
Как: выборка `Brand` с `OFFSET skip LIMIT limit`.
Почему: предоставить каталог брендов для интерфейса и фильтрации товаров.

Детали:
Параметры Query: `skip` (int ≥0), `limit` (int 1..500). Валидация происходит в FastAPI через `Query`. Порядок возвращения — как хранится в таблице без дополнительной сортировки. Ответ: JSON массив объектов `{id, name}`. Ошибки: не генерирует явных ошибок, кроме системных. Использование: клиент запрашивает страницу для заполнения выпадающего списка выбора бренда.
Структурировано:
Request: Method GET Path `/api/brands/`.
Query Params: `skip` (int, default 0, >=0); `limit` (int, default 50, 1..500).
Path Params: отсутствуют.
Body: отсутствует.
Internal Steps:

1. Принятие параметров с проверкой типов.
2. Формирование SQL: SELECT id,name FROM brands OFFSET :skip LIMIT :limit.
3. Выполнение запроса без сортировки.
4. Формирование массива объектов.
   Response Shape: `[ { id:int, name:str } ]`.
   Error Mapping: 422 (некорректный тип или диапазон параметров), прочие — системные.
   Data Sources: таблица `brands`.

### GET /api/brands/search?name=...

Что: поиск брендов по подстроке имени.
Как: фильтр `Brand.name ILIKE %name%` + пагинация.
Почему: позволяет пользователю быстро находить бренд при неизвестном точном написании.

Детали:
Параметры Query: `name` (строка 1..100), `skip`, `limit`. Логика: строит предикат ILIKE с шаблоном `%name%`. Возвращает массив совпавших брендов. Ошибки: при отсутствии результатов — пустой массив. Причина: поддержка частичного ввода и авто-дополнения.
Структурировано:
Request: GET `/api/brands/search`.
Query: `name` (str, required, length 1..100); `skip` (int ≥0); `limit` (int 1..500).
Steps:

1. Валидация обязательного `name`.
2. Построение SQL с ILIKE: WHERE name ILIKE '%' || :name || '%'.
3. Применение OFFSET/LIMIT.
4. Извлечение строк и упаковка в JSON.
   Response: `[ { id:int, name:str } ]` (может быть пустым).
   Errors: 422 (отсутствует или пустой `name`), системные.
   Data: `brands`.

### GET /api/brands/{brand_id}

Что: детальная информация о бренде.
Как: выборка по первичному ключу; 404 если отсутствует.
Почему: предоставить описательный объект для карточки/привязки к товару.

Детали:
Параметр Path: `brand_id` (int >0). Обработка: одиночный SELECT по ID. При отсутствии — исключение HTTP 404 с `detail="Brand not found"`. Ответ: JSON `{id, name}`. Использование: фронтенд получает подтверждение существования бренда перед созданием части.
Структурировано:
Request: GET `/api/brands/{brand_id}`.
Path: `brand_id` (int >0).
Steps:

1. Преобразование и проверка `brand_id`.
2. SELECT id,name FROM brands WHERE id=:brand_id.
3. Проверка результата; при None → 404.
4. Возврат объекта.
   Response: `{ id:int, name:str }`.
   Errors: 404 (не найден), 422 (некорректный тип id).
   Data: `brands`.

## 2. Админские эндпоинты (`/api/brands/admin`)

### GET /api/brands/admin

Что: постраничный список брендов (админ лимиты расширены до 1000).
Как: запрос всех записей с пагинацией.
Почему: администратор управляет большим списком и просматривает структуру брендов.

Детали:
Параметры Query: `skip` (≥0), `limit` (1..1000). Возвращает массив объектов. Отличие от публичного — увеличенный предел для интенсивной административной работы. Ошибки: нет специфичных.
Структурировано:
Request: GET `/api/brands/admin`.
Query: `skip` (int ≥0), `limit` (int 1..1000).
Steps: аналог публичного листинга c изменённым upper bound `limit`.
Response: `[ { id:int, name:str } ]`.
Errors: 422 (некорректные параметры), системные.
Data: `brands`.

### POST /api/brands/admin

Что: создание бренда.
Как: проверка существования имени, вставка записи, возврат созданного объекта.
Почему: наполнение справочника брендов для связывания с товарами.

Детали:
Тело: `{"name": "..."}` (валидируется схемой BrandCreate). Шаги: (1) SELECT по имени; (2) при нахождении конфликт → 409 с сообщением, включающим ID существующего; (3) INSERT; (4) COMMIT; (5) REFRESH. Ответ: созданный объект. Ошибки: 409 при дубликате.
Структурировано:
Request: POST `/api/brands/admin`.
Body Schema: `{ name:str (required, length 1..100) }`.
Steps:

1. Валидация тела против схемы.
2. SELECT id FROM brands WHERE name=:name.
3. Если найдено → 409.
4. INSERT INTO brands(name) VALUES(:name).
5. COMMIT + REFRESH.
   Response: `{ id:int, name:str }`.
   Errors: 409 (имя уже существует), 422 (нарушение схемы).
   Data: `brands`.

### GET /api/brands/admin/{brand_id}

Что: детальный просмотр бренда.
Как: выборка по ID; при отсутствии ошибка 404.
Почему: использование в админ-интерфейсе для редактирования и аудита.

Детали:
Path: `brand_id` (>0). Возврат полного объекта. При отсутствии — 404. Используется для формы редактирования.
Структурировано: идентично публичному детальному, но без отличий в наборе полей.

### PUT /api/brands/admin/{brand_id}

Что: обновление имени бренда.
Как: загрузка записи, проверка конфликта имени, применение частичных данных.
Почему: поддержание актуальности наименований.

Детали:
Тело: JSON с полем `name` (опционально). Шаги: (1) SELECT по ID; (2) проверка 404; (3) если новое имя и отличается — SELECT по имени; (4) при наличии конфликта 409; (5) обновление атрибута; (6) COMMIT+REFRESH. Ответ: обновлённый бренд.
Структурировано:
Request: PUT `/api/brands/admin/{brand_id}`.
Body: `{ name?:str (1..100) }`.
Steps:

1. SELECT бренд по ID.
2. Проверка наличия.
3. Если передано новое `name` и отличается → проверка уникальности.
4. Обновление поля в ORM.
5. COMMIT + REFRESH.
   Response: `{ id:int, name:str }`.
   Errors: 404 (не найден), 409 (конфликт имени), 422 (нарушение валидации).
   Data: `brands`.

### DELETE /api/brands/admin/{brand_id}?force=bool

Что: удаление бренда при отсутствии связанных частей или принудительно.
Как: подсчёт связанных `Part`; при наличии и `force=false` возврат ошибки; удаление.
Почему: управление жизненным циклом бренда и очистка справочника.

Детали:
Path: `brand_id`; Query: `force` (bool, по умолчанию false). Шаги: (1) SELECT бренд; (2) COUNT частей по brand_id; (3) если count>0 и force=false → 409; (4) DELETE + COMMIT. Ответ: пустой (204). Ошибки: 404, 409.
Структурировано:
Request: DELETE `/api/brands/admin/{brand_id}` + optional `force`.
Query: `force` (bool default=false).
Steps:

1. SELECT бренд.
2. COUNT parts WHERE brand_id=:id.
3. Если count>0 и force=false → 409.
4. DELETE + COMMIT.
   Response: статус 204 без тела.
   Errors: 404 (нет бренда), 409 (есть связанные части без force).
   Data: `brands`, связь с `parts`.

### POST /api/brands/admin/bulk-create

Что: массовое добавление брендов.
Как: итерация по входному списку, проверка уникальности имен, коллективная вставка.
Почему: ускорить первоначальное или пакетное наполнение справочника.

Детали:
Тело: массив объектов `{name}`. Логика: для каждой записи проверка существования имени; успешные собираются в список; после цикла — массовая вставка и один COMMIT. Ответ: статистика `{total, created, failed, errors, message}`. Ошибки: обработка дубликатов внутри итогового массива ошибок.
Структурировано:
Request: POST `/api/brands/admin/bulk-create`.
Body: `[ { name:str } , ... ]`.
Steps:

1. Инициализация счетчиков.
2. Для каждого элемента: валидация имени; проверка уникальности; при конфликте запись ошибки.
3. Добавление валидных объектов в сессию.
4. Один COMMIT.
   Response: `{ total:int, created:int, failed:int, errors:[str], message:str? }`.
   Errors: Внутри `errors` на уровне логики; HTTP 422 если тело не массив.
   Data: `brands`.

### GET /api/brands/admin/bulk-delete?ids=...&force=bool

Что: массовое удаление брендов.
Как: проверка каждого ID, анализ наличия связанных `Part`, условное удаление.
Почему: пакетное управление удалением при реорганизации ассортимента.

Детали:
Query: `ids` (список int), `force` (bool). Итерация: для каждого бренда проверка существования; затем COUNT частей; при наличии без force → добавление текстовой ошибки; успешные удаляются; один финальный COMMIT. Ответ: `{total, deleted, failed, errors, message}`.
Структурировано:
Request: GET `/api/brands/admin/bulk-delete` (семантически удаление, метод может быть POST/DELETE в другой реализации; здесь GET по исходному описанию).
Query: `ids` (CSV список int), `force` (bool default=false).
Steps:

1. Парсинг списка.
2. Для каждого id: SELECT бренд; если отсутствует → ошибка.
3. COUNT parts; при наличии и force=false → ошибка.
4. Маркировка к удалению валидных.
5. Один COMMIT.
   Response: `{ total:int, deleted:int, failed:int, errors:[str], message:str? }`.
   Errors: Логические собираются; 422 при некорректном формате ids.
   Data: `brands`, `parts`.

### GET /api/brands/admin/stats

Что: агрегированная статистика по брендам (количество товаров, топ-5).
Как: `LEFT JOIN Part` + группировка, расчёт суммарных и средних показателей.
Почему: обзор распределения ассортимента по брендам для аналитических решений.

Детали:
Сбор: общее число брендов; для каждого количество частей; вычисление брендов с/без частей; суммарный объём частей; среднее частей на бренд; сортировка для топ-5. Ответ: объект со сводными полями и массивом топовых брендов `{brand_id,name,parts_count}`. Ошибки: отсутствуют при нормальном потоке.
Структурировано:
Request: GET `/api/brands/admin/stats`.
Steps:

1. COUNT brands.
2. LEFT JOIN parts для подсчёта частей по брендам.
3. Расчёт суммарного количества частей.
4. Определение среднего (parts_total / brands_total при brands_total>0).
5. Сортировка для топ-5.
   Response: `{ brands_total:int, parts_total:int, avg_parts_per_brand:float?, brands_with_no_parts:int, top_brands:[{brand_id:int,name:str,parts_count:int}] }`.
   Errors: Отсутствие данных → поля c нулями; системные.
   Data: `brands`, `parts`.
